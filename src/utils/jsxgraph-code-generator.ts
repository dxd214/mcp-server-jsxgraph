/**
 * JSXGraph JavaScript Code Generator
 * Generates JSXGraph JavaScript code that can be embedded in HTML
 */

import { generateStepControllerCode } from './jsxgraph-step-controller';

/**
 * Replace __GRAPH_ID__ placeholder with actual container ID
 */
export function replaceGraphIdPlaceholder(code: string, actualId: string): string {
  return code.replace(/__GRAPH_ID__/g, actualId);
}

export interface JSXGraphConfig {
  type: "function" | "parametric" | "geometry" | "vector-field" | "linear-system" | 
        "function-transformation" | "quadratic-analysis" | "exponential-logarithm" |
        "rational-function" | "equation-system" | "conic-section" | "number-line-inequality" |
        "trigonometric-analysis";
  width?: number;
  height?: number;
  boundingBox?: number[];
  config: any;
  containerId?: string; // 容器元素的唯一ID，默认为 'jxgbox'
  pure?: boolean; // 是否生成纯净的代码片段，不包含包装器
  useGraphIdPlaceholder?: boolean; // 是否使用 __GRAPH_ID__ 占位符
}

export interface PolynomialStepConfig {
  polynomial: {
    expression: string;
    expandedForm?: string;
    zeros: Array<{
      x: number;
      multiplicity: number;
      behavior: 'crosses' | 'touches';
    }>;
    yIntercept: number;
    criticalPoints?: Array<{
      x: number;
      y: number;
      type: 'maximum' | 'minimum' | 'inflection';
    }>;
    degree: number;
    leadingCoefficient: number;
  };
  steps?: any[];
  title?: string;
  width?: number;
  height?: number;
  boundingBox?: [number, number, number, number];
  showControls?: boolean;
  autoPlay?: boolean;
  playSpeed?: number;
  containerId?: string; // 容器元素的唯一ID
  pure?: boolean; // 是否生成纯净的代码片段
  useGraphIdPlaceholder?: boolean; // 是否使用 __GRAPH_ID__ 占位符
}

export function generatePolynomialStepsCode(config: PolynomialStepConfig): string {
  const { polynomial, containerId = 'jxgbox', pure = false, useGraphIdPlaceholder = false } = config;
  const expandedForm = polynomial.expandedForm || polynomial.expression;
  
  // Use placeholder if requested, otherwise use actual containerId
  const graphId = useGraphIdPlaceholder ? '__GRAPH_ID__' : containerId;
  
  // Generate default steps if not provided
  const steps = config.steps || generateDefaultSteps(polynomial);
  
  // Generate step controller code (only if not pure)
  const stepControllerCode = pure ? '' : generateStepControllerCode({
    enableSteps: true,
    autoPlay: config.autoPlay || false,
    playSpeed: config.playSpeed || 3000,
    showControls: config.showControls !== false,
    animationDuration: 800,
    animationEasing: 'ease-in-out'
  });
  
  // 生成核心代码（纯净版本）
  const pureCode = `// Configuration
const config = ${JSON.stringify({
    title: config.title || 'Polynomial Function Analysis',
    polynomial: polynomial,
    boundingBox: config.boundingBox || [-6, 500, 6, -100],
    showControls: config.showControls !== false,
    autoPlay: config.autoPlay || false,
    playSpeed: config.playSpeed || 3000,
    containerId: graphId
  }, null, 2)};

// Initialize JSXGraph board
const board = JXG.JSXGraph.initBoard('${graphId}', {
  boundingbox: config.boundingBox,
  keepaspectratio: false,
  axis: true,
  grid: true,
  showCopyright: false,
  showNavigation: true,
  pan: { enabled: true, needShift: false },
  zoom: { enabled: true, wheel: true, needShift: false }
});

// Steps data
const steps = ${JSON.stringify(steps, null, 2)};

// Create initial visualization (Step 5 - complete curve)
const polynomial = config.polynomial;
const expandedForm = "${expandedForm}";

// Draw the complete polynomial curve
const mainCurve = board.create('functiongraph', [
  function(x) { return ${expandedForm.replace(/Math\.pow/g, 'Math.pow').replace(/x\*x\*x\*x/g, 'Math.pow(x,4)').replace(/x\*x\*x/g, 'Math.pow(x,3)').replace(/x\*x/g, 'Math.pow(x,2)')}; },
  -6, 6
], {
  strokeColor: '#cc0000',
  strokeWidth: 3
});

// Add x-intercepts (zeros)
${steps[0]?.elements ? `polynomial.zeros.forEach((zero, index) => {
  board.create('point', [zero.x, 0], {
    name: 'x=' + zero.x,
    size: 6,
    color: zero.behavior === 'crosses' ? '#0066cc' : '#ff9900',
    fixed: true
  });
});` : ''}

// Add y-intercept
board.create('point', [0, polynomial.yIntercept], {
  name: 'y=' + polynomial.yIntercept,
  size: 6,
  color: '#009900',
  fixed: true
});

// Add critical points if available
${polynomial.criticalPoints ? `polynomial.criticalPoints.forEach((point, index) => {
  board.create('point', [point.x, point.y], {
    name: '(' + point.x + ', ' + point.y + ')',
    size: 7,
    fillColor: '#cc0066',
    strokeColor: '#cc0066',
    fixed: true
  });
});` : ''}

// Add function label
board.create('text', [0, -80], {
  text: 'f(x) = ' + polynomial.expression,
  fontSize: 18,
  cssStyle: 'color: #cc0000; font-weight: bold'
});`;

  // 如果是纯净模式，直接返回核心代码
  if (pure) {
    return pureCode;
  }
  
  // 否则返回带包装的完整代码：包含步骤控制与通用元素创建（含 line 的多格式支持）
  const jsCode = `
// Polynomial Function Step-by-Step Analysis
// Generated by MCP Server Chart with Animation Support
// Container ID: ${graphId}

${stepControllerCode}

(function() {
  // 初始化 Board
  ${pureCode}

  // 通用元素创建器：支持 point/line/curve/arrow/text
  function createElement(elementConfig) {
    if (!elementConfig || !elementConfig.type) return null;
    var element = null;
    var style = elementConfig.style || {};

    switch (elementConfig.type) {
      case 'point': {
        var p = elementConfig.properties || {};
        var coords = p.coords || p.point || [0, 0];
        element = board.create('point', coords, {
          size: style.size || 4,
          fillColor: style.fillColor || style.color || '#0066cc',
          strokeColor: style.color || '#0066cc',
          fillOpacity: style.fillOpacity != null ? style.fillOpacity : 1,
          strokeOpacity: style.strokeOpacity != null ? style.strokeOpacity : 1,
          visible: style.visible !== false,
          name: p.name || ''
        });
        break;
      }
      case 'line': {
        var ls = {
          strokeColor: style.color || '#333333',
          strokeWidth: style.strokeWidth || 2,
          strokeOpacity: style.strokeOpacity != null ? style.strokeOpacity : 1,
          dash: style.dash || 0,
          visible: style.visible !== false
        };
        var lp = elementConfig.properties || {};
        // 支持三种格式：point1/point2、points 数组、equation 系数
        if (lp.point1 && lp.point2) {
          element = board.create('line', [lp.point1, lp.point2], ls);
        } else if (lp.points) {
          element = board.create('line', lp.points, ls);
        } else if (lp.equation) {
          var eq = lp.equation; // { a, b, c } => ax + by + c = 0
          element = board.create('line', [eq.a, eq.b, eq.c], ls);
        }
        break;
      }
      case 'curve': {
        var cs = {
          strokeColor: style.color || '#0066cc',
          strokeWidth: style.strokeWidth || 2,
          strokeOpacity: style.strokeOpacity != null ? style.strokeOpacity : 1,
          dash: style.dash || 0,
          visible: style.visible !== false
        };
        var cp = elementConfig.properties || {};
        if (cp.expression) {
          var expr = String(cp.expression)
            .replace(/Math\.pow/g, 'Math.pow')
            .replace(/Math\.sin/g, 'Math.sin')
            .replace(/Math\.cos/g, 'Math.cos')
            .replace(/Math\.sqrt/g, 'Math.sqrt')
            .replace(/Math\.exp/g, 'Math.exp')
            .replace(/Math\.log/g, 'Math.log');
          element = board.create('functiongraph', [
            new Function('x', 'return ' + expr),
            cp.domain ? cp.domain[0] : -10,
            cp.domain ? cp.domain[1] : 10
          ], cs);
        }
        break;
      }
      case 'arrow': {
        var ap = elementConfig.properties || {};
        element = board.create('arrow', ap.points || ap.point || [[0, 0], [1, 1]], {
          strokeColor: style.color || '#666666',
          strokeWidth: style.strokeWidth || 2,
          strokeOpacity: style.strokeOpacity != null ? style.strokeOpacity : 1,
          lastArrow: true,
          visible: style.visible !== false
        });
        break;
      }
      case 'text': {
        var tp = elementConfig.properties || {};
        element = board.create('text', [
          (tp.position && tp.position[0]) || 0,
          (tp.position && tp.position[1]) || 0,
          tp.text || ''
        ], {
          fontSize: style.fontSize || 14,
          cssStyle: 'color: ' + (style.color || '#333333') + '; font-weight: ' + (style.fontWeight || 'normal'),
          opacity: style.opacity != null ? style.opacity : 1,
          visible: style.visible !== false
        });
        break;
      }
    }
    return element;
  }

  // 注册步骤：如果提供了 steps，则逐步渲染
  if (typeof StepController !== 'undefined' && Array.isArray(steps)) {
    try {
      StepController.init(board);
      steps.forEach(function(stepData) {
        StepController.registerStep(function(boardInstance) {
          var elements = [];
          if (stepData.elements) {
            for (var i = 0; i < stepData.elements.length; i++) {
              var el = createElement(stepData.elements[i]);
              if (el) elements.push(el);
            }
          }
          if (stepData.annotations) {
            for (var j = 0; j < stepData.annotations.length; j++) {
              var ann = stepData.annotations[j];
              var s = ann.style || {};
              var t = board.create('text', [ann.position[0], ann.position[1], ann.text], {
                fontSize: s.fontSize || 14,
                cssStyle: 'color: ' + (s.color || '#333333') + '; font-weight: ' + (s.fontWeight || 'normal'),
                opacity: 1
              });
              elements.push(t);
            }
          }
          board.update();
          return elements;
        });
      });
    } catch (e) {
      console && console.warn && console.warn('StepController initialization failed:', e);
    }
  }

  // DOM 就绪处理（若需要）
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', function() {});
  }
})();
`;
  
  return jsCode;
}

// Generate default steps based on polynomial properties
function generateDefaultSteps(polynomial: any): any[] {
  const steps = [];
  const expandedForm = polynomial.expandedForm || polynomial.expression;
  
  // Step 1: End behavior
  steps.push({
    id: 'step1',
    title: 'Step 1: 确定端点行为',
    description: `主导项 ${polynomial.leadingCoefficient}x^${polynomial.degree}，${polynomial.degree % 2 === 0 ? '偶数' : '奇数'}次且系数为${polynomial.leadingCoefficient < 0 ? '负' : '正'}`,
    elements: [
      {
        type: 'arrow',
        id: 'leftEndBehavior',
        properties: { points: [[-5.5, 400], [-5.5, 200]] },
        style: { color: '#ff6600', strokeWidth: 3 }
      },
      {
        type: 'arrow',
        id: 'rightEndBehavior',
        properties: { points: [[5.5, 400], [5.5, 200]] },
        style: { color: '#ff6600', strokeWidth: 3 }
      },
      {
        type: 'text',
        id: 'leftEndText',
        properties: {
          position: [-5.5, 420],
          text: `x→-∞, f(x)→${polynomial.leadingCoefficient < 0 && polynomial.degree % 2 === 0 ? '-∞' : '+∞'}`
        },
        style: { color: '#ff6600', fontSize: 14 }
      },
      {
        type: 'text',
        id: 'rightEndText',
        properties: {
          position: [5.5, 420],
          text: `x→+∞, f(x)→${polynomial.leadingCoefficient < 0 ? '-∞' : '+∞'}`
        },
        style: { color: '#ff6600', fontSize: 14 }
      }
    ],
    annotations: [
      {
        text: `主导项: ${polynomial.leadingCoefficient}x^${polynomial.degree}`,
        position: [0, 470],
        style: { fontSize: 16, color: '#333', fontWeight: 'bold' }
      }
    ]
  });
  
  // Step 2: Intercepts
  const interceptElements = [];
  
  // X-intercepts
  polynomial.zeros.forEach((zero: any, index: number) => {
    interceptElements.push({
      type: 'point',
      id: `zero${index}`,
      properties: { coords: [zero.x, 0], name: `x=${zero.x}` },
      style: { 
        color: zero.behavior === 'crosses' ? '#0066cc' : '#ff9900', 
        size: 6 
      }
    });
  });
  
  // Y-intercept
  interceptElements.push({
    type: 'point',
    id: 'yIntercept',
    properties: { coords: [0, polynomial.yIntercept], name: `y=${polynomial.yIntercept}` },
    style: { color: '#009900', size: 6 }
  });
  
  steps.push({
    id: 'step2',
    title: 'Step 2: 找出截距',
    description: '标记x轴和y轴截距',
    elements: interceptElements
  });
  
  // Step 3: Multiplicity behavior
  const behaviorElements: any[] = [...interceptElements];
  const behaviorCurves: any[] = [];
  
  // Add behavior curves for each zero
  polynomial.zeros.forEach((zero: any, index: number) => {
    if (zero.behavior === 'touches') {
      // Add parabola-like curve for touching behavior
      behaviorCurves.push({
        type: 'curve',
        id: `behaviorCurve${index}`,
        properties: {
          expression: `30*Math.pow((x-${zero.x}), 2)`,
          domain: [zero.x - 0.5, zero.x + 0.5]
        },
        style: { color: '#ff9900', strokeWidth: 2, dash: 2 }
      });
    }
  });
  
  const pointers = polynomial.zeros.map((zero: any) => ({
    from: [zero.x, -70],
    to: [zero.x, -10],
    label: zero.behavior === 'crosses' ? '穿过(重数' + zero.multiplicity + ')' : '相切(重数' + zero.multiplicity + ')',
    style: { color: zero.behavior === 'crosses' ? '#0066cc' : '#ff9900' }
  }));
  
  steps.push({
    id: 'step3',
    title: 'Step 3: 确定零点的重数和行为',
    description: '零点的重数决定函数在该点的行为：奇数重数穿过x轴，偶数重数相切',
    elements: [...behaviorElements, ...behaviorCurves],
    pointers: pointers
  });
  
  // Step 4: Plot additional points
  const additionalPointsElements: any[] = [...interceptElements];
  const criticalPointElements: any[] = [];
  if (polynomial.criticalPoints && polynomial.criticalPoints.length > 0) {
    polynomial.criticalPoints.forEach((point: any, index: number) => {
      criticalPointElements.push({
        type: 'point',
        id: `critical${index}`,
        properties: { coords: [point.x, point.y], name: `(${point.x}, ${point.y})` },
        style: { color: '#cc0066', size: 7, fillColor: '#cc0066' }
      });
    });
  }
  
  steps.push({
    id: 'step4',
    title: 'Step 4: 绘制额外的关键点',
    description: '计算并标记函数上的其他重要点，帮助确定曲线形状',
    elements: [...additionalPointsElements, ...criticalPointElements],
    pointers: polynomial.criticalPoints ? polynomial.criticalPoints.map((point: any) => ({
      from: [point.x, point.y > 0 ? point.y - 50 : point.y + 50],
      to: [point.x, point.y > 0 ? point.y - 10 : point.y + 10],
      label: point.type === 'maximum' ? '峰值' : point.type,
      style: { color: '#cc0066', strokeWidth: 2, dash: 1 }
    })) : []
  });
  
  // Step 5: Sketch the complete curve
  const curveElements = [
    {
      type: 'curve',
      id: 'mainCurve',
      properties: { 
        expression: expandedForm.replace(/Math\.pow/g, 'Math.pow').replace(/x\*x\*x\*x/g, 'Math.pow(x,4)').replace(/x\*x\*x/g, 'Math.pow(x,3)').replace(/x\*x/g, 'Math.pow(x,2)'),
        domain: [-6, 6]
      },
      style: { color: '#cc0000', strokeWidth: 3 }
    },
    ...additionalPointsElements,
    ...criticalPointElements
  ];
  
  steps.push({
    id: 'step5',
    title: 'Step 5: 绘制完整的函数曲线',
    description: '连接所有点，根据端点行为和零点重数绘制平滑曲线',
    elements: curveElements,
    annotations: [
      {
        text: `f(x) = ${polynomial.expression}`,
        position: [0, -80],
        style: { fontSize: 18, color: '#cc0000', fontWeight: 'bold' }
      }
    ]
  });
  
  // Step 6: Verification
  steps.push({
    id: 'step6',
    title: 'Step 6: 验证',
    description: '检查所有特征：✓ 端点行为 ✓ x轴截距和重数 ✓ y轴截距 ✓ 关键点',
    elements: [
      ...curveElements,
      // Add grid lines for key points
      ...polynomial.zeros.map((zero: any, index: number) => ({
        type: 'line',
        id: `gridLine${index}`,
        properties: { points: [[zero.x, -100], [zero.x, 500]] },
        style: { color: '#e0e0e0', strokeWidth: 1, dash: 1 }
      } as any))
    ],
    annotations: [
      {
        text: '✓ 端点行为正确',
        position: [-5, 470],
        style: { fontSize: 12, color: '#008800' }
      },
      {
        text: `✓ ${polynomial.zeros.length}个零点`,
        position: [-5, 440],
        style: { fontSize: 12, color: '#008800' }
      },
      {
        text: `✓ Y轴截距: ${polynomial.yIntercept}`,
        position: [-5, 410],
        style: { fontSize: 12, color: '#008800' }
      }
    ]
  });
  
  return steps;
}

/**
 * Generate JSXGraph JavaScript code for any chart type
 */
export function generateJSXGraphCode(config: JSXGraphConfig): string {
  const { type, width = 800, height = 600, boundingBox = [-10, 10, 10, -10], containerId = 'jxgbox', pure = false, useGraphIdPlaceholder = false } = config;
  
  // Use placeholder if requested, otherwise use actual containerId
  const graphId = useGraphIdPlaceholder ? '__GRAPH_ID__' : containerId;
  
  let jsCode = '';
  
  switch (type) {
    case 'function':
      jsCode = generateFunctionGraphCode(config.config, boundingBox, graphId);
      break;
    case 'parametric':
      jsCode = generateParametricCurveCode(config.config, boundingBox, graphId);
      break;
    case 'geometry':
      jsCode = generateGeometryDiagramCode(config.config, boundingBox, graphId);
      break;
    case 'vector-field':
      jsCode = generateVectorFieldCode(config.config, boundingBox, graphId);
      break;
    case 'linear-system':
      jsCode = generateLinearSystemCode(config.config, boundingBox, graphId);
      break;
    case 'function-transformation':
      jsCode = generateFunctionTransformationCode(config.config, boundingBox, graphId);
      break;
    case 'quadratic-analysis':
      jsCode = generateQuadraticAnalysisCode(config.config, boundingBox, graphId);
      break;
    case 'exponential-logarithm':
      jsCode = generateExponentialLogarithmCode(config.config, boundingBox, graphId);
      break;
    case 'rational-function':
      jsCode = generateRationalFunctionCode(config.config, boundingBox, graphId);
      break;
    case 'equation-system':
      jsCode = generateEquationSystemCode(config.config, boundingBox, graphId);
      break;
    case 'conic-section':
      jsCode = generateConicSectionCode(config.config, boundingBox, graphId);
      break;
    case 'number-line-inequality':
      jsCode = generateNumberLineInequalityCode(config.config, boundingBox, graphId);
      break;
    case 'trigonometric-analysis':
      jsCode = generateTrigonometricAnalysisCode(graphId, config);
      break;
    default:
      jsCode = generateFunctionGraphCode(config.config, boundingBox, graphId);
  }
  
  // 如果需要纯净代码片段，直接返回核心代码
  if (pure) {
    return jsCode.trim();
  }
  
  // 否则返回包含完整包装器的代码
  return `
// JSXGraph Mathematical Visualization
// Generated by MCP Server Chart
// Container ID: ${graphId}

(function() {
  // Wait for DOM to be ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeChart);
  } else {
    initializeChart();
  }
  
  function initializeChart() {
    // Make sure JSXGraph is loaded
    if (typeof JXG === 'undefined') {
      console.error('JSXGraph library not loaded. Please include JSXGraph script and CSS files.');
      return;
    }
    
    // Make sure the container exists
    const container = document.getElementById('${graphId}');
    if (!container) {
      console.error('Container element with id "${graphId}" not found.');
      return;
    }
    
    // Set container dimensions - width adaptive, height fixed at 400px
    container.style.width = '100%';
    container.style.height = '400px';
    
    ${jsCode}
    
    // Make board accessible globally if needed
    // Use unique board reference for multiple charts
    if (typeof board !== 'undefined') {
      window.jsxBoard_${graphId} = board;
    }
  }
})();
`;
}

function generateFunctionGraphCode(config: any, boundingBox: number[], containerId: string = 'jxgbox'): string {
  const boardConfig = {
    boundingbox: boundingBox,
    axis: config.style?.axis !== false,
    grid: config.style?.grid !== false,
    keepaspectratio: config.keepAspectRatio || false,
    showCopyright: config.showCopyright || false,
    showNavigation: config.showNavigation !== false,
    zoom: config.zoom || { enabled: true, wheel: true },
    pan: config.pan || { enabled: true }
  };
  
  let code = `
    var board = JXG.JSXGraph.initBoard('${containerId}', ${JSON.stringify(boardConfig)});
    
    // Add title if provided
    ${config.title ? `board.create('text', [${boundingBox[0] + 1}, ${boundingBox[1] - 0.5}, '${config.title}'], {fontSize: 18, fontWeight: 'bold'});` : ''}
    
    // Add axis labels
    ${config.axisXTitle ? `board.create('text', [${boundingBox[2] - 1}, 0.5, '${config.axisXTitle}'], {fontSize: 14});` : ''}
    ${config.axisYTitle ? `board.create('text', [0.5, ${boundingBox[1] - 1}, '${config.axisYTitle}'], {fontSize: 14});` : ''}
  `;
  
  // Add functions
  if (config.functions) {
    config.functions.forEach((func: any, index: number) => {
      const domain = func.domain || [boundingBox[0], boundingBox[2]];
      code += `
        var f${index} = board.create('functiongraph', [
          function(x) { return ${func.expression}; },
          ${domain[0]}, ${domain[1]}
        ], {
          strokeColor: '${func.color || '#0066cc'}',
          strokeWidth: ${func.strokeWidth || 2},
          dash: ${func.dash || 0},
          name: '${func.name || ''}'
        });
      `;
      
      // Add derivative if requested for first function
      if (index === 0 && config.showDerivative) {
        code += `
          board.create('functiongraph', [
            JXG.Math.Numerics.D(f0.Y),
            ${domain[0]}, ${domain[1]}
          ], {
            strokeColor: '#ff6600',
            strokeWidth: 2,
            dash: 2,
            name: "f'(x)"
          });
        `;
      }
      
      // Add integral area if requested for first function
      if (index === 0 && config.showIntegral && config.integralBounds) {
        const [a, b] = config.integralBounds;
        code += `
          board.create('integral', [[${a}, ${b}], f0], {
            fillColor: '#0066cc',
            fillOpacity: 0.3,
            curveLeft: { visible: false },
            curveRight: { visible: false }
          });
        `;
      }
      
      // Add tangent line if requested for first function
      if (index === 0 && config.tangentAt !== undefined) {
        code += `
          var tPoint = board.create('glider', [${config.tangentAt}, 0, f0], {
            name: 'P',
            size: 4,
            color: '#ff0000'
          });
          board.create('tangent', [tPoint], {
            strokeColor: '#ff9900',
            strokeWidth: 2,
            dash: 1
          });
        `;
      }
    });
  }
  
  // Add points
  if (config.points) {
    config.points.forEach((point: any, index: number) => {
      code += `
        board.create('point', [${point.x}, ${point.y}], {
          name: '${point.name || ''}',
          size: ${point.size || 3},
          color: '${point.color || '#ff0000'}',
          fixed: true
        });
      `;
    });
  }
  
  return code;
}

function generateParametricCurveCode(config: any, boundingBox: number[], containerId: string = 'jxgbox'): string {
  const boardConfig = {
    boundingbox: boundingBox,
    axis: config.style?.axis !== false,
    grid: config.style?.grid !== false,
    keepaspectratio: config.keepAspectRatio || false,
    showCopyright: config.showCopyright || false,
    showNavigation: config.showNavigation !== false,
    zoom: config.zoom || { enabled: true, wheel: true },
    pan: config.pan || { enabled: true }
  };
  
  let code = `
    var board = JXG.JSXGraph.initBoard('${containerId}', ${JSON.stringify(boardConfig)});
    
    // Add title if provided
    ${config.title ? `board.create('text', [${boundingBox[0] + 1}, ${boundingBox[1] - 0.5}, '${config.title}'], {fontSize: 18, fontWeight: 'bold'});` : ''}
    
    // Add axis labels
    ${config.axisXTitle ? `board.create('text', [${boundingBox[2] - 1}, 0.5, '${config.axisXTitle}'], {fontSize: 14});` : ''}
    ${config.axisYTitle ? `board.create('text', [0.5, ${boundingBox[1] - 1}, '${config.axisYTitle}'], {fontSize: 14});` : ''}
  `;
  
  // Add parametric curves
  if (config.curves) {
    config.curves.forEach((curve: any, index: number) => {
      code += `
        var curve${index} = board.create('curve', [
          function(t) { return ${curve.xExpression}; },
          function(t) { return ${curve.yExpression}; },
          ${curve.tMin || 0}, ${curve.tMax || 2 * Math.PI}
        ], {
          strokeColor: '${curve.color || '#0066cc'}',
          strokeWidth: ${curve.strokeWidth || 2},
          dash: ${curve.dash || 0}
        });
      `;
      
      // Add trace point if requested for first curve
      if (index === 0 && config.showTrace) {
        code += `
          var t = board.create('slider', [[${boundingBox[0] + 1}, ${boundingBox[3] + 1}], [${boundingBox[0] + 4}, ${boundingBox[3] + 1}], [${curve.tMin || 0}, ${curve.tMin || 0}, ${curve.tMax || 2 * Math.PI}]], {
            name: 't',
            snapWidth: 0.01
          });
          
          var tracePoint = board.create('point', [
            function() { var tVal = t.Value(); return ${curve.xExpression.replace(/t/g, 'tVal')}; },
            function() { var tVal = t.Value(); return ${curve.yExpression.replace(/t/g, 'tVal')}; }
          ], {
            size: 4,
            color: '#ff0000',
            name: 'Trace'
          });
        `;
      }
    });
  }
  
  // Add points
  if (config.points) {
    config.points.forEach((point: any, index: number) => {
      code += `
        board.create('point', [${point.x}, ${point.y}], {
          name: '${point.name || ''}',
          size: ${point.size || 3},
          color: '${point.color || '#ff0000'}',
          fixed: true
        });
      `;
    });
  }
  
  return code;
}

function generateGeometryDiagramCode(config: any, boundingBox: number[], containerId: string = 'jxgbox'): string {
  const boardConfig = {
    boundingbox: boundingBox,
    axis: config.style?.axis !== false,
    grid: config.style?.grid !== false,
    keepaspectratio: config.keepAspectRatio !== false,
    showCopyright: config.showCopyright || false,
    showNavigation: config.showNavigation !== false,
    zoom: config.zoom || { enabled: true, wheel: true },
    pan: config.pan || { enabled: true }
  };
  
  let code = `
    var board = JXG.JSXGraph.initBoard('${containerId}', ${JSON.stringify(boardConfig)});
    var points = {};
    var lines = {};
    var circles = {};
    
    // Add title if provided
    ${config.title ? `board.create('text', [${boundingBox[0] + 1}, ${boundingBox[1] - 0.5}, '${config.title}'], {fontSize: 18, fontWeight: 'bold'});` : ''}
  `;
  
  // Create points
  if (config.points) {
    config.points.forEach((point: any) => {
      code += `
        points['${point.name || `p_${point.x}_${point.y}`}'] = board.create('point', [${point.x}, ${point.y}], {
          name: '${point.name || ''}',
          size: ${point.size || 4},
          color: '${point.color || '#0066cc'}',
          fixed: ${point.fixed || false},
          visible: ${point.visible !== false}
        });
      `;
    });
  }
  
  // Create lines
  if (config.lines) {
    config.lines.forEach((line: any, index: number) => {
      const lineType = line.type || 'segment';
      const createMethod = lineType === 'line' ? 'line' : lineType === 'ray' ? 'arrow' : 'segment';
      code += `
        if (points['${line.point1}'] && points['${line.point2}']) {
          lines['${line.name || `${line.point1}-${line.point2}`}'] = board.create('${createMethod}', [
            points['${line.point1}'], points['${line.point2}']
          ], {
            strokeColor: '${line.color || '#333333'}',
            strokeWidth: ${line.strokeWidth || 2},
            dash: ${line.dash || 0},
            name: '${line.name || ''}',
            straightFirst: ${lineType === 'line'},
            straightLast: ${lineType === 'line' || lineType === 'ray'}
          });
        }
      `;
    });
  }
  
  // Create circles
  if (config.circles) {
    config.circles.forEach((circle: any, index: number) => {
      if (circle.radius !== undefined) {
        code += `
          if (points['${circle.center}']) {
            circles['circle${index}'] = board.create('circle', [
              points['${circle.center}'], ${circle.radius}
            ], {
              strokeColor: '${circle.color || '#0066cc'}',
              fillColor: '${circle.fillColor || 'transparent'}',
              fillOpacity: ${circle.fillOpacity || 0},
              strokeWidth: ${circle.strokeWidth || 2}
            });
          }
        `;
      } else if (circle.throughPoint) {
        code += `
          if (points['${circle.center}'] && points['${circle.throughPoint}']) {
            circles['circle${index}'] = board.create('circle', [
              points['${circle.center}'], points['${circle.throughPoint}']
            ], {
              strokeColor: '${circle.color || '#0066cc'}',
              fillColor: '${circle.fillColor || 'transparent'}',
              fillOpacity: ${circle.fillOpacity || 0},
              strokeWidth: ${circle.strokeWidth || 2}
            });
          }
        `;
      }
    });
  }
  
  // Create polygons
  if (config.polygons) {
    config.polygons.forEach((polygon: any, index: number) => {
      const verticesStr = polygon.vertices.map((v: string) => `points['${v}']`).join(', ');
      code += `
        var vertices${index} = [${verticesStr}].filter(p => p);
        if (vertices${index}.length >= 3) {
          board.create('polygon', vertices${index}, {
            borders: {
              strokeColor: '${polygon.color || '#0066cc'}',
              strokeWidth: ${polygon.strokeWidth || 2}
            },
            fillColor: '${polygon.fillColor || '#0066cc'}',
            fillOpacity: ${polygon.fillOpacity || 0.3}
          });
        }
      `;
    });
  }
  
  // Create angles
  if (config.angles) {
    config.angles.forEach((angle: any, index: number) => {
      code += `
        if (points['${angle.point1}'] && points['${angle.vertex}'] && points['${angle.point2}']) {
          board.create('angle', [
            points['${angle.point1}'], points['${angle.vertex}'], points['${angle.point2}']
          ], {
            radius: ${angle.radius || 30} / board.unitX,
            type: '${angle.type || 'arc'}',
            color: '${angle.color || '#ff9900'}',
            fillOpacity: ${angle.fillOpacity || 0.3},
            label: {
              visible: ${angle.label !== false}
            }
          });
        }
      `;
    });
  }
  
  // Add geometric constructions
  if (config.construction) {
    // Perpendiculars
    if (config.construction.perpendicular) {
      config.construction.perpendicular.forEach((perp: any) => {
        code += `
          if (lines['${perp.line}'] && points['${perp.throughPoint}']) {
            board.create('perpendicular', [lines['${perp.line}'], points['${perp.throughPoint}']], {
              strokeColor: '#666666',
              strokeWidth: 1,
              dash: 2
            });
          }
        `;
      });
    }
    
    // Parallels
    if (config.construction.parallel) {
      config.construction.parallel.forEach((par: any) => {
        code += `
          if (lines['${par.line}'] && points['${par.throughPoint}']) {
            board.create('parallel', [lines['${par.line}'], points['${par.throughPoint}']], {
              strokeColor: '#666666',
              strokeWidth: 1,
              dash: 2
            });
          }
        `;
      });
    }
    
    // Midpoints
    if (config.construction.midpoint) {
      config.construction.midpoint.forEach((mid: any) => {
        code += `
          if (points['${mid.point1}'] && points['${mid.point2}']) {
            points['${mid.name}'] = board.create('midpoint', [
              points['${mid.point1}'], points['${mid.point2}']
            ], {
              name: '${mid.name}',
              size: 3,
              color: '#009900'
            });
          }
        `;
      });
    }
  }
  
  return code;
}

function generateVectorFieldCode(config: any, boundingBox: number[], containerId: string = 'jxgbox'): string {
  const boardConfig = {
    boundingbox: boundingBox,
    axis: config.style?.axis !== false,
    grid: config.style?.grid !== false,
    keepaspectratio: config.keepAspectRatio || false,
    showCopyright: config.showCopyright || false,
    showNavigation: config.showNavigation !== false,
    zoom: config.zoom || { enabled: true, wheel: true },
    pan: config.pan || { enabled: true }
  };
  
  const density = config.density || 10;
  const scale = config.scale || 0.8;
  const arrowStyle = config.arrowStyle || {};
  
  let code = `
    var board = JXG.JSXGraph.initBoard('${containerId}', ${JSON.stringify(boardConfig)});
    
    // Add title if provided
    ${config.title ? `board.create('text', [${boundingBox[0] + 1}, ${boundingBox[1] - 0.5}, '${config.title}'], {fontSize: 18, fontWeight: 'bold'});` : ''}
    
    // Add axis labels
    ${config.axisXTitle ? `board.create('text', [${boundingBox[2] - 1}, 0.5, '${config.axisXTitle}'], {fontSize: 14});` : ''}
    ${config.axisYTitle ? `board.create('text', [0.5, ${boundingBox[1] - 1}, '${config.axisYTitle}'], {fontSize: 14});` : ''}
    
    // Vector field function
    var fieldDx = function(x, y) { return ${config.fieldFunction.dx}; };
    var fieldDy = function(x, y) { return ${config.fieldFunction.dy}; };
    
    // Create vector field
    var xStep = (${boundingBox[2]} - ${boundingBox[0]}) / ${density};
    var yStep = (${boundingBox[1]} - ${boundingBox[3]}) / ${density};
    
    for (var x = ${boundingBox[0]} + xStep/2; x < ${boundingBox[2]}; x += xStep) {
      for (var y = ${boundingBox[3]} + yStep/2; y < ${boundingBox[1]}; y += yStep) {
        (function(x0, y0) {
          var dx = fieldDx(x0, y0);
          var dy = fieldDy(x0, y0);
          var magnitude = Math.sqrt(dx*dx + dy*dy);
          
          if (magnitude > 0.001) {
            var scaleFactor = ${scale} * Math.min(xStep, yStep) / 2;
            var endX = x0 + dx * scaleFactor / magnitude;
            var endY = y0 + dy * scaleFactor / magnitude;
            
            ${config.colorByMagnitude ? `
              var hue = Math.min(magnitude * 30, 240);
              var color = 'hsl(' + (240 - hue) + ', 100%, 50%)';
            ` : `
              var color = '${arrowStyle.color || '#0066cc'}';
            `}
            
            board.create('arrow', [
              [x0, y0], [endX, endY]
            ], {
              strokeColor: color,
              strokeWidth: ${arrowStyle.strokeWidth || 1.5},
              lastArrow: {
                type: 2,
                size: ${arrowStyle.headSize || 5}
              }
            });
          }
        })(x, y);
      }
    }
  `;
  
  // Add streamlines
  if (config.streamlines) {
    config.streamlines.forEach((streamline: any, index: number) => {
      code += `
        // Streamline ${index}
        var streamPoints${index} = [];
        var x = ${streamline.startX};
        var y = ${streamline.startY};
        var dt = 0.01;
        var steps = ${streamline.steps || 100};
        
        streamPoints${index}.push([x, y]);
        
        for (var i = 0; i < steps; i++) {
          var dx = fieldDx(x, y);
          var dy = fieldDy(x, y);
          var magnitude = Math.sqrt(dx*dx + dy*dy);
          
          if (magnitude < 0.001) break;
          
          x += dx * dt;
          y += dy * dt;
          
          if (x < ${boundingBox[0]} || x > ${boundingBox[2]} || 
              y < ${boundingBox[3]} || y > ${boundingBox[1]}) break;
          
          streamPoints${index}.push([x, y]);
        }
        
        if (streamPoints${index}.length > 1) {
          board.create('curve', [
            streamPoints${index}.map(p => p[0]),
            streamPoints${index}.map(p => p[1])
          ], {
            strokeColor: '${streamline.color || '#ff6600'}',
            strokeWidth: ${streamline.strokeWidth || 2}
          });
        }
      `;
    });
  }
  
  // Add singular points
  if (config.singularPoints) {
    config.singularPoints.forEach((point: any) => {
      code += `
        board.create('point', [${point.x}, ${point.y}], {
          name: '${point.type || ''}',
          size: ${point.size || 5},
          color: '${point.color || '#ff0000'}',
          fixed: true
        });
      `;
    });
  }
  
  // Add magnitude legend if requested
  if (config.showMagnitudeLegend && config.colorByMagnitude) {
    code += `
      // Create magnitude legend
      var legendX = ${boundingBox[2]} - 2;
      var legendY = ${boundingBox[1]} - 1;
      var legendHeight = 3;
      
      for (var i = 0; i <= 10; i++) {
        var y = legendY - i * legendHeight / 10;
        var hue = 240 - i * 24;
        var color = 'hsl(' + hue + ', 100%, 50%)';
        
        board.create('line', [
          [legendX, y], [legendX + 0.3, y]
        ], {
          strokeColor: color,
          strokeWidth: 3,
          straightFirst: false,
          straightLast: false
        });
      }
      
      board.create('text', [legendX + 0.5, legendY, 'High'], {fontSize: 10});
      board.create('text', [legendX + 0.5, legendY - legendHeight, 'Low'], {fontSize: 10});
      board.create('text', [legendX + 0.2, legendY + 0.3, 'Magnitude'], {fontSize: 11});
    `;
  }
  
  return code;
}

// Generate code for linear systems (equations and inequalities)
function generateLinearSystemCode(config: any, boundingBox: number[], containerId: string = 'jxgbox'): string {
  const boardConfig = {
    boundingbox: boundingBox,
    axis: config.style?.axis !== false,
    grid: config.style?.grid !== false,
    keepaspectratio: config.keepAspectRatio || false,
    showCopyright: config.showCopyright || false,
    showNavigation: config.showNavigation !== false,
    zoom: config.zoom || { enabled: true, wheel: true },
    pan: config.pan || { enabled: true }
  };
  
  let code = `
    var board = JXG.JSXGraph.initBoard('${containerId}', ${JSON.stringify(boardConfig)});
    
    // Add title if provided
    ${config.title ? `board.create('text', [${boundingBox[0] + 1}, ${boundingBox[1] - 0.5}, '${config.title}'], {fontSize: 18, fontWeight: 'bold'});` : ''}
    
    // Add axis labels
    ${config.axisXTitle ? `board.create('text', [${boundingBox[2] - 1}, 0.5, '${config.axisXTitle}'], {fontSize: 14});` : ''}
    ${config.axisYTitle ? `board.create('text', [0.5, ${boundingBox[1] - 1}, '${config.axisYTitle}'], {fontSize: 14});` : ''}
    
    var lines = [];
    var intersections = [];
  `;
  
  // Add linear equations (lines)
  if (config.equations) {
    config.equations.forEach((eq: any, index: number) => {
      // For line ax + by = c, we need to convert to JSXGraph line format [a, b, c]
      // JSXGraph uses the form ax + by + c = 0, so we need to negate c
      code += `
        // Equation ${index + 1}: ${eq.a}x + ${eq.b}y = ${eq.c}
        lines[${index}] = board.create('line', [${eq.a}, ${eq.b}, ${-eq.c}], {
          strokeColor: '${eq.color || '#0066cc'}',
          strokeWidth: ${eq.strokeWidth || 2},
          dash: ${eq.dash || 0},
          name: '${eq.name || `${eq.a}x + ${eq.b}y = ${eq.c}`}',
          withLabel: ${eq.name ? 'true' : 'false'}
        });
      `;
    });
    
    // Add intersection points if requested
    if (config.showIntersections !== false && config.equations.length >= 2) {
      code += `
        // Calculate and show intersection points
        for (var i = 0; i < lines.length - 1; i++) {
          for (var j = i + 1; j < lines.length; j++) {
            var intersection = board.create('intersection', [lines[i], lines[j], 0], {
              name: '',
              size: 4,
              color: '#ff0000',
              fixed: true
            });
            if (intersection && !isNaN(intersection.X()) && !isNaN(intersection.Y())) {
              intersections.push(intersection);
              // Add label for intersection point
              board.create('text', [
                intersection.X() + 0.3,
                intersection.Y() + 0.3,
                '(' + intersection.X().toFixed(2) + ', ' + intersection.Y().toFixed(2) + ')'
              ], {fontSize: 10, color: '#ff0000'});
            }
          }
        }
      `;
    }
  }
  
  // Add linear inequalities with shading
  if (config.inequalities) {
    config.inequalities.forEach((ineq: any, index: number) => {
      const lineIndex = (config.equations?.length || 0) + index;
      
      // Create the boundary line
      code += `
        // Inequality ${index + 1}: ${ineq.a}x + ${ineq.b}y ${ineq.type} ${ineq.c}
        var ineqLine${index} = board.create('line', [${ineq.a}, ${ineq.b}, ${-ineq.c}], {
          strokeColor: '${ineq.borderColor || '#0066cc'}',
          strokeWidth: 2,
          dash: ${(ineq.type === '<' || ineq.type === '>') ? (ineq.borderDash || 2) : 0},
          name: '${ineq.name || `${ineq.a}x + ${ineq.b}y ${ineq.type} ${ineq.c}`}'
        });
        
        // Create inequality shading
        board.create('inequality', [ineqLine${index}], {
          inverse: ${(ineq.type === '>=' || ineq.type === '>') ? 'true' : 'false'},
          fillColor: '${ineq.fillColor || '#0066cc'}',
          fillOpacity: ${ineq.fillOpacity || 0.2}
        });
      `;
    });
  }
  
  // Add additional points
  if (config.points) {
    config.points.forEach((point: any, index: number) => {
      code += `
        board.create('point', [${point.x}, ${point.y}], {
          name: '${point.name || ''}',
          size: ${point.size || 4},
          color: '${point.color || '#ff0000'}',
          fixed: true
        });
      `;
    });
  }
  
  // Add objective function visualization if provided
  if (config.objectives && config.objectives.length > 0) {
    config.objectives.forEach((obj: any, index: number) => {
      code += `
        // Objective function: ${obj.name || 'z'} = ${obj.a}x + ${obj.b}y
        // Create level curves for the objective function
        var objLevels${index} = [];
        var step = (${boundingBox[2]} - ${boundingBox[0]}) / 5;
        for (var level = -10; level <= 10; level += 2) {
          var c = level * step;
          objLevels${index}.push(board.create('line', [${obj.a}, ${obj.b}, c], {
            strokeColor: '#ff9900',
            strokeWidth: 1,
            dash: 1,
            strokeOpacity: 0.5
          }));
        }
      `;
    });
  }
  
  return code;
}

function generateFunctionTransformationCode(config: any, boundingBox: number[], containerId: string = 'jxgbox'): string {
  // For now, use function graph code as a fallback
  return generateFunctionGraphCode(config, boundingBox, containerId);
}

function generateQuadraticAnalysisCode(config: any, boundingBox: number[], containerId: string = 'jxgbox'): string {
  // For now, use function graph code as a fallback
  return generateFunctionGraphCode(config, boundingBox, containerId);
}

function generateExponentialLogarithmCode(config: any, boundingBox: number[], containerId: string = 'jxgbox'): string {
  const boardConfig = {
    boundingbox: boundingBox,
    axis: config.style?.axis !== false,
    grid: config.style?.grid !== false,
    keepaspectratio: config.keepAspectRatio || false,
    showCopyright: config.showCopyright || false,
    showNavigation: config.showNavigation !== false,
    zoom: config.zoom || { enabled: true, wheel: true },
    pan: config.pan || { enabled: true }
  };

  let code = `
    var board = JXG.JSXGraph.initBoard('${containerId}', ${JSON.stringify(boardConfig)});
    
    // Add title if provided
    ${config.title ? `board.create('text', [${boundingBox[0] + 1}, ${boundingBox[1] - 1}, '${config.title}'], {fontSize: 18, fontWeight: 'bold'});` : ''}
    
    // Add axis labels
    ${config.axisXTitle ? `board.create('text', [${boundingBox[2] - 1}, 0.5, '${config.axisXTitle}'], {fontSize: 14});` : ''}
    ${config.axisYTitle ? `board.create('text', [0.5, ${boundingBox[1] - 1}, '${config.axisYTitle}'], {fontSize: 14});` : ''}
    
    // Helper functions
    function safeLog(x, base) {
      if (x <= 0) return NaN;
      return Math.log(x) / Math.log(base);
    }
    
    function safeExp(x, base) {
      if (base <= 0 || base === 1) return NaN;
      try {
        var result = Math.pow(base, x);
        return isFinite(result) ? result : NaN;
      } catch(e) {
        return NaN;
      }
    }
  `;

  // Show y=x line for inverse relationships if requested
  if (config.showReflectionLine) {
    code += `
    // y = x line for inverse relationship
    var reflectionLine = board.create('line', [
      [${boundingBox[0]}, ${boundingBox[0]}], 
      [${boundingBox[2]}, ${boundingBox[2]}]
    ], {
      strokeColor: '#cccccc',
      strokeWidth: 1,
      dash: 2,
      name: 'y = x',
      straightFirst: false,
      straightLast: false
    });
    `;
  }

  // Draw each function
  if (config.functions && config.functions.length > 0) {
    config.functions.forEach((func: any, index: number) => {
      const {
        type,
        base = Math.E,
        coefficient = 1,
        hShift = 0,
        vShift = 0,
        expression,
        color = '#0066cc',
        strokeWidth = 2,
        name,
        dash = 0,
        domain
      } = func;

      code += `
    // ${type.toUpperCase()} FUNCTION ${index + 1}${name ? ` - ${name}` : ''}
    (function() {
      var base = ${base};
      var coefficient = ${coefficient};
      var hShift = ${hShift};
      var vShift = ${vShift};
      var color = '${color}';
      var strokeWidth = ${strokeWidth};
      var dash = ${dash};
      var domain = ${domain ? JSON.stringify(domain) : 'null'};
      `;

      if (expression) {
        // Custom expression
        code += `
      var f = function(x) {
        if (domain && (x < domain[0] || x > domain[1])) return NaN;
        return ${expression.replace(/x/g, 'x')};
      };
      `;
      } else if (type === 'exponential') {
        code += `
      var f = function(x) {
        if (domain && (x < domain[0] || x > domain[1])) return NaN;
        return coefficient * safeExp(x - hShift, base) + vShift;
      };
      `;
      } else if (type === 'logarithm') {
        code += `
      var f = function(x) {
        if (domain && (x < domain[0] || x > domain[1])) return NaN;
        var input = x - hShift;
        return coefficient * safeLog(input, base) + vShift;
      };
      `;
      }

      code += `
      var curve = board.create('functiongraph', [f], {
        strokeColor: color,
        strokeWidth: strokeWidth,
        dash: dash,
        name: '${name || `${type}${index + 1}`}'
      });
    `;

      // Show asymptotes
      if (config.showAsymptotes !== false) {
        if (type === 'exponential') {
          // Horizontal asymptote
          code += `
      // Horizontal asymptote y = ${vShift}
      board.create('line', [
        [${boundingBox[0]}, ${vShift}], 
        [${boundingBox[2]}, ${vShift}]
      ], {
        strokeColor: color,
        strokeWidth: 1,
        dash: 2,
        opacity: 0.6,
        name: 'y = ' + ${vShift},
        straightFirst: false,
        straightLast: false
      });
      `;
        } else if (type === 'logarithm') {
          // Vertical asymptote
          code += `
      // Vertical asymptote x = ${hShift}
      board.create('line', [
        [${hShift}, ${boundingBox[3]}], 
        [${hShift}, ${boundingBox[1]}]
      ], {
        strokeColor: color,
        strokeWidth: 1,
        dash: 2,
        opacity: 0.6,
        name: 'x = ' + ${hShift},
        straightFirst: false,
        straightLast: false
      });
      `;
        }
      }

      // Show intercepts
      if (config.showIntercepts !== false) {
        if (type === 'exponential') {
          // Y-intercept
          const yIntercept = coefficient * Math.pow(base, -hShift) + vShift;
          code += `
      // Y-intercept at (0, ${yIntercept.toFixed(3)})
      var yIntercept = ${yIntercept};
      board.create('point', [0, yIntercept], {
        size: 4,
        color: color,
        fillColor: color,
        strokeColor: color,
        name: '(0, ' + yIntercept.toFixed(2) + ')',
        fixed: true
      });
      `;
          
          // X-intercept (if it exists and is finite)
          if (vShift !== 0) {
            const xIntercept = hShift + Math.log(-vShift / coefficient) / Math.log(base);
            if (isFinite(xIntercept) && xIntercept >= boundingBox[0] && xIntercept <= boundingBox[2]) {
              code += `
      // X-intercept at (${xIntercept.toFixed(3)}, 0)
      var xIntercept = ${xIntercept};
      board.create('point', [xIntercept, 0], {
        size: 4,
        color: color,
        fillColor: color,
        strokeColor: color,
        name: '(' + xIntercept.toFixed(2) + ', 0)',
        fixed: true
      });
      `;
            }
          }
        } else if (type === 'logarithm') {
          // X-intercept
          const xIntercept = Math.pow(base, -vShift / coefficient) + hShift;
          if (isFinite(xIntercept) && xIntercept >= boundingBox[0] && xIntercept <= boundingBox[2]) {
            code += `
      // X-intercept at (${xIntercept.toFixed(3)}, 0)
      var xIntercept = ${xIntercept};
      board.create('point', [xIntercept, 0], {
        size: 4,
        color: color,
        fillColor: color,
        strokeColor: color,
        name: '(' + xIntercept.toFixed(2) + ', 0)',
        fixed: true
      });
      `;
          }
        }
      }

      // Show inverse function if requested
      if (config.showInverse) {
        code += `
      // Inverse function
      var inverseF;
      if ('${type}' === 'exponential') {
        // Inverse of exponential is logarithm
        inverseF = function(x) {
          var adjustedX = x - vShift;
          if (adjustedX <= 0 || coefficient === 0) return NaN;
          return hShift + safeLog(adjustedX / coefficient, base);
        };
      } else {
        // Inverse of logarithm is exponential
        inverseF = function(x) {
          var adjustedX = x - vShift;
          return hShift + safeExp(adjustedX / coefficient, base);
        };
      }
      
      var inverseCurve = board.create('functiongraph', [inverseF], {
        strokeColor: color,
        strokeWidth: strokeWidth,
        dash: 1,
        opacity: 0.7,
        name: 'inverse of ' + '${name || `${type}${index + 1}`}'
      });
      `;
      }

      code += `
    })();
    `;
    });
  }

  // Add special points
  if (config.specialPoints && config.specialPoints.length > 0) {
    config.specialPoints.forEach((point: any, index: number) => {
      const { x, y, label, color = '#ff0000', size = 4 } = point;
      code += `
    // Special point ${index + 1}${label ? ` - ${label}` : ''}
    board.create('point', [${x}, ${y}], {
      size: ${size},
      color: '${color}',
      fillColor: '${color}',
      strokeColor: '${color}',
      name: '${label || `SP${index + 1}`}',
      fixed: true
    });
    `;
    });
  }

  // Add comparison points
  if (config.comparisonPoints && config.comparisonPoints.length > 0) {
    config.comparisonPoints.forEach((cp: any, index: number) => {
      const { x, showValues = true } = cp;
      if (showValues && config.functions) {
        code += `
    // Comparison at x = ${x}
    var compX = ${x};
    var compLine = board.create('line', [
      [compX, ${boundingBox[3]}], 
      [compX, ${boundingBox[1]}]
    ], {
      strokeColor: '#999999',
      strokeWidth: 1,
      dash: 3,
      opacity: 0.5,
      name: 'x = ' + compX,
      straightFirst: false,
      straightLast: false
    });
    `;

        config.functions.forEach((func: any, funcIndex: number) => {
          code += `
    // Mark function value at comparison point
    var funcValue${funcIndex} = curve.Y ? curve.Y(compX) : NaN;
    if (isFinite(funcValue${funcIndex})) {
      board.create('point', [compX, funcValue${funcIndex}], {
        size: 3,
        color: '${func.color || '#0066cc'}',
        fillColor: '${func.color || '#0066cc'}',
        strokeColor: '${func.color || '#0066cc'}',
        name: 'f(${x}) = ' + funcValue${funcIndex}.toFixed(2),
        fixed: true
      });
    }
    `;
        });
      }
    });
  }

  // Add tangent lines at specified points
  if (config.tangentAt && config.tangentAt.length > 0 && config.functions) {
    config.tangentAt.forEach((x: number, index: number) => {
      code += `
    // Tangent line at x = ${x}
    var tangentX = ${x};
    var h = 0.001; // Small increment for derivative approximation
    
    // Calculate derivative numerically for the first function
    var fVal = f(tangentX);
    var fValNext = f(tangentX + h);
    var slope = (fValNext - fVal) / h;
    
    if (isFinite(fVal) && isFinite(slope)) {
      var tangentLine = board.create('line', [
        [tangentX - 1, fVal - slope],
        [tangentX + 1, fVal + slope]
      ], {
        strokeColor: '${config.functions[0]?.color || '#0066cc'}',
        strokeWidth: 1,
        dash: 1,
        opacity: 0.8,
        name: 'tangent at x=' + tangentX,
        straightFirst: false,
        straightLast: false
      });
      
      // Mark the point of tangency
      board.create('point', [tangentX, fVal], {
        size: 3,
        color: '${config.functions[0]?.color || '#0066cc'}',
        fillColor: '${config.functions[0]?.color || '#0066cc'}',
        strokeColor: '${config.functions[0]?.color || '#0066cc'}',
        name: 'tangent point',
        fixed: true
      });
    }
    `;
    });
  }

  // Add growth/decay analysis
  if (config.growthDecayAnalysis?.show) {
    const { initialValue, timeUnit = 't', rateLabel = 'rate' } = config.growthDecayAnalysis;
    code += `
    // Growth/Decay Analysis
    ${initialValue !== undefined ? `
    board.create('text', [${boundingBox[0] + 1}, ${boundingBox[1] - 2}, 'Initial Value: ${initialValue}'], {
      fontSize: 12, color: '#333333'
    });
    ` : ''}
    
    board.create('text', [${boundingBox[0] + 1}, ${boundingBox[1] - 3}, 'Time Unit: ${timeUnit}'], {
      fontSize: 12, color: '#333333'
    });
    `;
  }

  // Do not return from within injected code to avoid illegal return in some embedding contexts

  return code;
}

function generateRationalFunctionCode(config: any, boundingBox: number[], containerId: string = 'jxgbox'): string {
  // For now, use function graph code as a fallback
  return generateFunctionGraphCode(config, boundingBox, containerId);
}

function generateEquationSystemCode(config: any, boundingBox: number[], containerId: string = 'jxgbox'): string {
  // For now, use function graph code as a fallback
  return generateFunctionGraphCode(config, boundingBox, containerId);
}

function generateConicSectionCode(config: any, boundingBox: number[], containerId: string = 'jxgbox'): string {
  const boardConfig = {
    boundingbox: boundingBox,
    axis: config.style?.axis !== false,
    grid: config.style?.grid !== false,
    keepaspectratio: config.keepAspectRatio || false,
    showCopyright: config.showCopyright || false,
    showNavigation: config.showNavigation !== false,
    zoom: config.zoom || { enabled: true, wheel: true },
    pan: config.pan || { enabled: true }
  };

  let code = `
    var board = JXG.JSXGraph.initBoard('${containerId}', ${JSON.stringify(boardConfig)});
    
    // Add title if provided
    ${config.title ? `board.create('text', [${boundingBox[0] + 1}, ${boundingBox[1] - 1}, '${config.title}'], {fontSize: 18, fontWeight: 'bold'});` : ''}
    
    // Add axis labels
    ${config.axisXTitle ? `board.create('text', [${boundingBox[2] - 1}, 0.5, '${config.axisXTitle}'], {fontSize: 14});` : ''}
    ${config.axisYTitle ? `board.create('text', [0.5, ${boundingBox[1] - 1}, '${config.axisYTitle}'], {fontSize: 14});` : ''}
    
    // Helper functions
    function degToRad(deg) { return deg * Math.PI / 180; }
    function radToDeg(rad) { return rad * 180 / Math.PI; }
  `;

  // Draw standard conic sections
  if (config.conics && config.conics.length > 0) {
    config.conics.forEach((conic: any, index: number) => {
      const {
        type,
        center = { x: 0, y: 0 },
        radius,
        a,
        b,
        p,
        vertex = { x: 0, y: 0 },
        orientation = 'vertical',
        rotation = 0,
        color = '#0066cc',
        strokeWidth = 2,
        fillColor,
        fillOpacity = 0,
        name,
        dash = 0
      } = conic;

      code += `
    // ${type.toUpperCase()} ${index + 1}${name ? ` - ${name}` : ''}
    (function() {
      var center = [${center.x}, ${center.y}];
      var rotation = degToRad(${rotation});
      var color = '${color}';
      var strokeWidth = ${strokeWidth};
      var dash = ${dash};
      var fillColor = '${fillColor || 'transparent'}';
      var fillOpacity = ${fillOpacity};
      `;

      switch (type) {
        case 'circle':
          code += `
      // Circle with radius ${radius}
      var circle = board.create('circle', [center, ${radius || 1}], {
        strokeColor: color,
        strokeWidth: strokeWidth,
        dash: dash,
        fillColor: fillColor,
        fillOpacity: fillOpacity,
        name: '${name || `C${index + 1}`}'
      });
      `;
          break;

        case 'ellipse':
          code += `
      // Ellipse with semi-major axis a=${a} and semi-minor axis b=${b}
      var a = ${a || 3};
      var b = ${b || 2};
      // Axis direction unit vectors with rotation
      var ux = [Math.cos(rotation), Math.sin(rotation)];
      var uy = [-Math.sin(rotation), Math.cos(rotation)];
      // Points on the endpoints of semi-axes
      var pA = [center[0] + a * ux[0], center[1] + a * ux[1]];
      var pB = [center[0] + b * uy[0], center[1] + b * uy[1]];
      
      var ellipse = board.create('ellipse', [center, pA, pB], {
        strokeColor: color,
        strokeWidth: strokeWidth,
        dash: dash,
        fillColor: fillColor,
        fillOpacity: fillOpacity,
        name: '${name || `E${index + 1}`}'
      });
      
      // Compute foci for optional display
      var c = Math.sqrt(Math.abs(a*a - b*b));
      var f1 = a >= b 
        ? [center[0] - c * ux[0], center[1] - c * ux[1]]
        : [center[0] - c * uy[0], center[1] - c * uy[1]];
      var f2 = a >= b 
        ? [center[0] + c * ux[0], center[1] + c * ux[1]]
        : [center[0] + c * uy[0], center[1] + c * uy[1]];
      `;
          break;

        case 'parabola':
          code += `
      // Parabola with parameter p=${p}, vertex at (${vertex.x}, ${vertex.y}), ${orientation}
      var vertex = [${vertex.x}, ${vertex.y}];
      var p = ${p || 1};
      var orientation = '${orientation}';
      
      var focus, directrix;
      if (orientation === 'vertical') {
        focus = [vertex[0], vertex[1] + p/4];
        directrix = board.create('line', [
          [vertex[0] - 3, vertex[1] - p/4], 
          [vertex[0] + 3, vertex[1] - p/4]
        ], {
          strokeColor: color,
          strokeWidth: 1,
          dash: 2,
          opacity: 0.5,
          name: 'directrix',
          straightFirst: false,
          straightLast: false
        });
      } else {
        focus = [vertex[0] + p/4, vertex[1]];
        directrix = board.create('line', [
          [vertex[0] - p/4, vertex[1] - 3], 
          [vertex[0] - p/4, vertex[1] + 3]
        ], {
          strokeColor: color,
          strokeWidth: 1,
          dash: 2,
          opacity: 0.5,
          name: 'directrix',
          straightFirst: false,
          straightLast: false
        });
      }
      
      var parabola = board.create('parabola', [focus, directrix], {
        strokeColor: color,
        strokeWidth: strokeWidth,
        dash: dash,
        name: '${name || `P${index + 1}`}'
      });
      `;
          break;

        case 'hyperbola':
          code += `
      // Hyperbola with parameters a=${a}, b=${b}
      var a = ${a || 2};
      var b = ${b || 1.5};
      var c = Math.sqrt(a*a + b*b);
      
      var f1 = [center[0] - c, center[1]];
      var f2 = [center[0] + c, center[1]];
      
      var hyperbola = board.create('hyperbola', [f1, f2, a], {
        strokeColor: color,
        strokeWidth: strokeWidth,
        dash: dash,
        name: '${name || `H${index + 1}`}'
      });
      
      // Draw asymptotes
      if (${config.showAsymptotes !== false}) {
        var slope1 = b/a;
        var slope2 = -b/a;
        board.create('line', [center, [center[0] + 1, center[1] + slope1]], {
          strokeColor: color,
          strokeWidth: 1,
          dash: 2,
          opacity: 0.6,
          name: 'asymptote1'
        });
        board.create('line', [center, [center[0] + 1, center[1] + slope2]], {
          strokeColor: color,
          strokeWidth: 1,
          dash: 2,
          opacity: 0.6,
          name: 'asymptote2'
        });
      }
      `;
          break;
      }

      // Add foci markers
      if (config.showFoci !== false && (type === 'ellipse' || type === 'hyperbola' || type === 'parabola')) {
        code += `
      // Mark foci
      if (typeof f1 !== 'undefined') {
        board.create('point', f1, {
          size: 4,
          color: color,
          fillColor: color,
          strokeColor: color,
          name: 'F1',
          fixed: true
        });
      }
      if (typeof f2 !== 'undefined') {
        board.create('point', f2, {
          size: 4,
          color: color,
          fillColor: color,
          strokeColor: color,
          name: 'F2',
          fixed: true
        });
      }
      if (typeof focus !== 'undefined') {
        board.create('point', focus, {
          size: 4,
          color: color,
          fillColor: color,
          strokeColor: color,
          name: 'F',
          fixed: true
        });
      }
      `;
      }

      // Add center marker
      if (config.showCenter !== false && (type === 'circle' || type === 'ellipse' || type === 'hyperbola')) {
        code += `
      board.create('point', center, {
        size: 3,
        color: color,
        fillColor: color,
        strokeColor: color,
        name: 'O',
        fixed: true
      });
      `;
      }

      // Add vertices
      if (config.showVertices !== false) {
        if (type === 'parabola') {
          code += `
      board.create('point', vertex, {
        size: 4,
        color: color,
        fillColor: color,
        strokeColor: color,
        name: 'V',
        fixed: true
      });
      `;
        } else if (type === 'ellipse' || type === 'hyperbola') {
          code += `
      // Mark vertices
      var vertices = [];
      if ('${type}' === 'ellipse') {
        var majorAxis = Math.max(a, b);
        var minorAxis = Math.min(a, b);
        vertices = [
          [center[0] - majorAxis, center[1]],
          [center[0] + majorAxis, center[1]],
          [center[0], center[1] - minorAxis],
          [center[0], center[1] + minorAxis]
        ];
      } else {
        vertices = [
          [center[0] - a, center[1]],
          [center[0] + a, center[1]]
        ];
      }
      
      vertices.forEach(function(v, i) {
        board.create('point', v, {
          size: 3,
          color: color,
          fillColor: color,
          strokeColor: color,
          name: 'V' + (i+1),
          fixed: true
        });
      });
      `;
        }
      }

      code += `
    })();
    `;
    });
  }

  // Draw general conic equations: Ax² + Bxy + Cy² + Dx + Ey + F = 0
  if (config.generalConics && config.generalConics.length > 0) {
    config.generalConics.forEach((conic: any, index: number) => {
      const { A, B, C, D, E, F, color = '#009900', strokeWidth = 2, name } = conic;
      
      code += `
    // General conic ${index + 1}: ${A}x² + ${B}xy + ${C}y² + ${D}x + ${E}y + ${F} = 0
    var generalConic${index} = board.create('implicitcurve', [
      function(x, y) {
        return ${A}*x*x + ${B}*x*y + ${C}*y*y + ${D}*x + ${E}*y + ${F};
      }
    ], {
      strokeColor: '${color}',
      strokeWidth: ${strokeWidth},
      name: '${name || `GC${index + 1}`}'
    });
    `;
    });
  }

  // Draw high-degree polynomials
  if (config.polynomials && config.polynomials.length > 0) {
    config.polynomials.forEach((poly: any, index: number) => {
      const { coefficients, color = '#ff6600', strokeWidth = 2, name, dash = 0 } = poly;
      
      // Build polynomial expression
      let polyExpression = '';
      coefficients.forEach((coeff: number, i: number) => {
        if (coeff === 0) return;
        
        if (polyExpression && coeff > 0) polyExpression += ' + ';
        else if (coeff < 0) polyExpression += ' - ';
        
        const absCoeff = Math.abs(coeff);
        if (i === 0) {
          polyExpression += absCoeff;
        } else if (i === 1) {
          polyExpression += `${absCoeff === 1 ? '' : absCoeff}*x`;
        } else {
          polyExpression += `${absCoeff === 1 ? '' : absCoeff}*Math.pow(x, ${i})`;
        }
      });

      code += `
    // Polynomial ${index + 1}${name ? ` - ${name}` : ''}: ${polyExpression}
    var poly${index} = board.create('functiongraph', [
      function(x) {
        return ${coefficients.map((c: number, i: number) => 
          i === 0 ? c :
          i === 1 ? `${c}*x` :
          `${c}*Math.pow(x, ${i})`
        ).join(' + ')};
      }
    ], {
      strokeColor: '${color}',
      strokeWidth: ${strokeWidth},
      dash: ${dash},
      name: '${name || `P${index + 1}`}'
    });
    `;

      // Mark polynomial roots if enabled
      if (config.showPolynomialRoots !== false) {
        code += `
    // Find and mark approximate roots for polynomial ${index + 1}
    var roots = [];
    for (var x = ${boundingBox[0]}; x <= ${boundingBox[2]}; x += 0.1) {
      var y = poly${index}.Y(x);
      var nextY = poly${index}.Y(x + 0.1);
      if (Math.abs(y) < 0.1 || (y * nextY < 0)) {
        // Potential root found
        var root = JXG.Math.Numerics.fzero(poly${index}.Y, [x, x + 0.1]);
        if (root && Math.abs(poly${index}.Y(root)) < 0.01) {
          roots.push(root);
          board.create('point', [root, 0], {
            size: 4,
            color: '${color}',
            fillColor: '${color}',
            strokeColor: '${color}',
            name: 'r' + roots.length,
            fixed: true
          });
        }
      }
    }
    `;
      }
    });
  }

  // Add intersection analysis if enabled
  if (config.intersectionAnalysis?.enabled && config.intersectionAnalysis?.between) {
    const [i1, i2] = config.intersectionAnalysis.between;
    code += `
    // Find intersections between curve ${i1} and curve ${i2}
    // This is a placeholder - intersection finding requires more complex implementation
    `;
  }

  // Do not return from within injected code to avoid illegal return in some embedding contexts

  return code;
}

function generateNumberLineInequalityCode(config: any, boundingBox: number[], containerId: string = 'jxgbox'): string {
  const boardConfig = {
    boundingbox: boundingBox,
    axis: config.style?.axis !== false,
    grid: config.style?.grid !== false,
    keepaspectratio: config.keepAspectRatio || false,
    showCopyright: config.showCopyright || false,
    showNavigation: config.showNavigation !== false,
    zoom: config.zoom || { enabled: true, wheel: true },
    pan: config.pan || { enabled: true }
  };

  const numberLineY = config.numberLinePosition || 0;
  const tickInterval = config.tickInterval || 1;
  const numberInterval = config.numberInterval || 1;
  const showTickMarks = config.tickMarks !== false;
  const showNumbers = config.showNumbers !== false;

  let code = `
    var board = JXG.JSXGraph.initBoard('${containerId}', ${JSON.stringify(boardConfig)});
    
    // Add title if provided
    ${config.title ? `board.create('text', [${boundingBox[0] + 1}, ${boundingBox[1] - 1}, '${config.title}'], {fontSize: 18, fontWeight: 'bold'});` : ''}
    
    // Draw number line
    var numberLine = board.create('line', [[${boundingBox[0]}, ${numberLineY}], [${boundingBox[2]}, ${numberLineY}]], {
      strokeColor: '#000000',
      strokeWidth: 2,
      straightFirst: false,
      straightLast: false
    });
  `;

  // Add tick marks and numbers
  if (showTickMarks || showNumbers) {
    code += `
      // Add tick marks and numbers
      var xMin = ${boundingBox[0]};
      var xMax = ${boundingBox[2]};
      var tickStep = ${tickInterval};
      var numberStep = ${numberInterval};
      
      for (var x = Math.ceil(xMin / tickStep) * tickStep; x <= xMax; x += tickStep) {
        if (Math.abs(x) < 0.0001) x = 0; // Handle floating point precision
        
        ${showTickMarks ? `
          // Create tick mark
          board.create('line', [
            [x, ${numberLineY} - 0.1], 
            [x, ${numberLineY} + 0.1]
          ], {
            strokeColor: '#000000',
            strokeWidth: 1,
            straightFirst: false,
            straightLast: false
          });
        ` : ''}
        
        ${showNumbers ? `
          // Add number label
          if (x % numberStep === 0) {
            board.create('text', [x, ${numberLineY} - 0.4, x.toString()], {
              fontSize: 12,
              anchorX: 'middle',
              anchorY: 'top'
            });
          }
        ` : ''}
      }
    `;
  }

  // Add inequalities
  if (config.inequalities) {
    config.inequalities.forEach((inequality: any, index: number) => {
      code += `
        // Process inequality ${index + 1}: ${inequality.expression}
        var ineq${index} = parseInequality('${inequality.expression}');
        
        if (ineq${index}) {
          drawInequality(board, ineq${index}, ${numberLineY}, {
            color: '${inequality.color || '#0066cc'}',
            strokeWidth: ${inequality.strokeWidth || 3},
            showEndpoints: ${inequality.showEndpoints !== false},
            endpointRadius: ${inequality.endpointRadius || 0.15},
            name: '${inequality.name || ''}'
          });
        }
      `;
    });
  }

  // Add inequality parsing and drawing functions
  code += `
    
    // Function to parse inequality expressions
    function parseInequality(expr) {
      expr = expr.replace(/\\s/g, ''); // Remove spaces
      
      // Handle compound inequalities like "2 < x < 5" or "-3 <= x <= 1"
      var compoundMatch = expr.match(/^(-?\\d*\\.?\\d+)\\s*(<|<=)\\s*x\\s*(<|<=)\\s*(-?\\d*\\.?\\d+)$/);
      if (compoundMatch) {
        var [, leftVal, leftOp, rightOp, rightVal] = compoundMatch;
        return {
          type: 'compound',
          leftValue: parseFloat(leftVal),
          leftOperator: leftOp,
          rightValue: parseFloat(rightVal),
          rightOperator: rightOp
        };
      }
      
      // Handle simple inequalities like "x > 2", "x <= -1"
      var simpleMatch = expr.match(/^x\\s*([<>=]+)\\s*(-?\\d*\\.?\\d+)$/) || 
                       expr.match(/^(-?\\d*\\.?\\d+)\\s*([<>=]+)\\s*x$/);
      if (simpleMatch) {
        var value, operator;
        if (expr.startsWith('x')) {
          [, operator, value] = simpleMatch;
        } else {
          [, value, operator] = simpleMatch;
          // Flip operator when number is on the left
          operator = operator.replace('<', 'temp').replace('>', '<').replace('temp', '>');
        }
        
        return {
          type: 'simple',
          value: parseFloat(value),
          operator: operator
        };
      }
      
      console.warn('Could not parse inequality:', expr);
      return null;
    }
    
    // Function to draw inequality on number line
    function drawInequality(board, inequality, yPos, options) {
      var color = options.color || '#0066cc';
      var strokeWidth = options.strokeWidth || 3;
      var showEndpoints = options.showEndpoints !== false;
      var endpointRadius = options.endpointRadius || 0.15;
      
      if (inequality.type === 'simple') {
        var value = inequality.value;
        var operator = inequality.operator;
        var xMin = ${boundingBox[0]};
        var xMax = ${boundingBox[2]};
        
        // Draw the ray/line segment
        if (operator === '>' || operator === '>=') {
          // Ray going right
          board.create('line', [
            [value, yPos], [xMax, yPos]
          ], {
            strokeColor: color,
            strokeWidth: strokeWidth,
            straightFirst: false,
            straightLast: false
          });
        } else if (operator === '<' || operator === '<=') {
          // Ray going left  
          board.create('line', [
            [xMin, yPos], [value, yPos]
          ], {
            strokeColor: color,
            strokeWidth: strokeWidth,
            straightFirst: false,
            straightLast: false
          });
        }
        
        // Draw endpoint
        if (showEndpoints) {
          var isInclusive = operator === '>=' || operator === '<=';
          board.create('point', [value, yPos], {
            size: endpointRadius * 30,
            fillColor: isInclusive ? color : 'white',
            strokeColor: color,
            strokeWidth: 2,
            name: '',
            fixed: true
          });
        }
        
      } else if (inequality.type === 'compound') {
        var leftValue = inequality.leftValue;
        var rightValue = inequality.rightValue;
        var leftOperator = inequality.leftOperator;
        var rightOperator = inequality.rightOperator;
        
        // Draw the line segment between the values
        board.create('line', [
          [leftValue, yPos], [rightValue, yPos]
        ], {
          strokeColor: color,
          strokeWidth: strokeWidth,
          straightFirst: false,
          straightLast: false
        });
        
        // Draw endpoints
        if (showEndpoints) {
          // Left endpoint
          var leftInclusive = leftOperator === '<=';
          board.create('point', [leftValue, yPos], {
            size: endpointRadius * 30,
            fillColor: leftInclusive ? color : 'white',
            strokeColor: color,
            strokeWidth: 2,
            name: '',
            fixed: true
          });
          
          // Right endpoint
          var rightInclusive = rightOperator === '<=';
          board.create('point', [rightValue, yPos], {
            size: endpointRadius * 30,
            fillColor: rightInclusive ? color : 'white',
            strokeColor: color,
            strokeWidth: 2,
            name: '',
            fixed: true
          });
        }
      }
      
      // Add inequality label if provided
      if (options.name) {
        var labelX = inequality.type === 'compound' ? 
          (inequality.leftValue + inequality.rightValue) / 2 : 
          inequality.value;
        board.create('text', [labelX, yPos + 0.5, options.name], {
          fontSize: 12,
          color: color,
          anchorX: 'middle'
        });
      }
    }
  `;

  return code;
}

/**
 * Generate JSXGraph code for comprehensive trigonometric function analysis
 */
export function generateTrigonometricAnalysisCode(containerId: string, config: JSXGraphConfig): string {
  const {
    functions,
    analysisOptions = {},
    points = [],
    xAxisUnit = "radians",
    showGrid = true,
    gridType = "standard",
  } = config.config;

  const {
    boundingBox = [-10, 10, 10, -10],
    width,
    height,
  } = config;

  const { 
    title, 
    axisXTitle, 
    axisYTitle,
    showCopyright,
    showNavigation,
    zoom,
    pan,
    keepAspectRatio,
    style
  } = config.config;

  if (!functions || functions.length === 0) {
    throw new Error("At least one trigonometric function is required");
  }

  const boardConfig = {
    boundingbox: boundingBox,
    axis: true,
    grid: showGrid,
    showCopyright: showCopyright ?? false,
    showNavigation: showNavigation ?? true,
    zoom: zoom ?? { wheel: true },
    pan: pan ?? { enabled: true },
    keepaspectratio: keepAspectRatio ?? false,
    ...(style || {}),
  };

  let code = `
    var board = JXG.JSXGraph.initBoard('${containerId}', ${JSON.stringify(boardConfig)});
    
    // Add title if provided
    ${title ? `board.create('text', [${boundingBox[0] + 1}, ${boundingBox[1] - 0.5}, '${title}'], {fontSize: 18, fontWeight: 'bold'});` : ''}
    
    // Add axis labels
    ${axisXTitle ? `board.create('text', [${boundingBox[2] - 1}, 0.5, '${axisXTitle}'], {fontSize: 14});` : ''}
    ${axisYTitle ? `board.create('text', [0.5, ${boundingBox[1] - 1}, '${axisYTitle}'], {fontSize: 14});` : ''}
    
    // Helper functions for trigonometric calculations
    function getTrigFunction(type, x, transformation) {
      var t = transformation || {};
      var A = t.amplitude || 1;
      var B = t.frequency || 1;
      var C = t.phaseShift || 0;
      var D = t.verticalShift || 0;
      
      var input = B * x + C;
      var result;
      
      switch(type) {
        case 'sin': result = A * Math.sin(input) + D; break;
        case 'cos': result = A * Math.cos(input) + D; break;
        case 'tan': result = A * Math.tan(input) + D; break;
        case 'csc': result = A * (1/Math.sin(input)) + D; break;
        case 'sec': result = A * (1/Math.cos(input)) + D; break;
        case 'cot': result = A * (1/Math.tan(input)) + D; break;
        case 'asin': result = A * Math.asin(input) + D; break;
        case 'acos': result = A * Math.acos(input) + D; break;
        case 'atan': result = A * Math.atan(input) + D; break;
        case 'sinh': result = A * Math.sinh(input) + D; break;
        case 'cosh': result = A * Math.cosh(input) + D; break;
        case 'tanh': result = A * Math.tanh(input) + D; break;
        default: result = 0;
      }
      
      return isFinite(result) ? result : NaN;
    }
    
    function getPeriod(type, frequency) {
      var B = frequency || 1;
      switch(type) {
        case 'sin': case 'cos': case 'csc': case 'sec': 
          return 2 * Math.PI / Math.abs(B);
        case 'tan': case 'cot':
          return Math.PI / Math.abs(B);
        default:
          return 2 * Math.PI / Math.abs(B);
      }
    }
    
    function hasAsymptotes(type) {
      return ['tan', 'cot', 'sec', 'csc'].includes(type);
    }
    
    function getAsymptotePositions(type, transformation, xMin, xMax) {
      var t = transformation || {};
      var B = t.frequency || 1;
      var C = t.phaseShift || 0;
      var positions = [];
      
      var offset, period;
      if (type === 'tan' || type === 'cot') {
        offset = type === 'tan' ? Math.PI/2 : 0;
        period = Math.PI / Math.abs(B);
      } else if (type === 'sec') {
        offset = Math.PI/2;
        period = 2 * Math.PI / Math.abs(B);
      } else if (type === 'csc') {
        offset = 0;
        period = 2 * Math.PI / Math.abs(B);
      }
      
      var baseAsymptote = (offset - C) / B;
      var n = Math.floor((xMin - baseAsymptote) / period);
      
      for (var i = n; i <= n + Math.ceil((xMax - xMin) / period) + 2; i++) {
        var x = baseAsymptote + i * period;
        if (x >= xMin && x <= xMax) {
          positions.push(x);
        }
      }
      
      return positions;
    }
  `;

  // Plot each trigonometric function
  functions.forEach((func: any, index: number) => {
    const {
      type,
      transformation = {},
      color = "#0066cc",
      strokeWidth = 2,
      name,
      domain,
      dash = 0,
      showAsymptotes = false,
    } = func;

    // Create function curve
    code += `
    // Function ${index + 1}: ${type}
    (function() {
      var funcColor = '${color}';
      var transformation = ${JSON.stringify(transformation)};
      var domain = ${domain ? JSON.stringify(domain) : 'null'};
      var strokeWidth = ${strokeWidth};
      var dash = ${dash};
      
      var f = function(x) {
        if (domain && (x < domain[0] || x > domain[1])) return NaN;
        return getTrigFunction('${type}', x, transformation);
      };
      
      var curve = board.create('functiongraph', [f], {
        strokeColor: funcColor,
        strokeWidth: strokeWidth,
        dash: dash,
        name: '${name || `${type}${index + 1}`}'
      });
    `;

    // Add asymptotes if requested and applicable
    if (showAsymptotes && ['tan', 'cot', 'sec', 'csc'].includes(type)) {
      code += `
      // Add vertical asymptotes
      var asymptotes = getAsymptotePositions('${type}', transformation, ${boundingBox[0]}, ${boundingBox[2]});
      asymptotes.forEach(function(x) {
        board.create('line', [
          [x, ${boundingBox[3]}], [x, ${boundingBox[1]}]
        ], {
          strokeColor: funcColor,
          strokeWidth: 1,
          dash: 2,
          opacity: 0.5,
          straightFirst: false,
          straightLast: false
        });
      });
      `;
    }

    code += `
    })();
    `;
  });

  // Analysis options
  if (analysisOptions.showPeriodMarkers) {
    code += `
    // Add period markers
    ${JSON.stringify(functions)}.forEach(function(func, index) {
      var period = getPeriod(func.type, func.transformation ? func.transformation.frequency : 1);
      var phaseShift = func.transformation ? func.transformation.phaseShift || 0 : 0;
      var frequency = func.transformation ? func.transformation.frequency || 1 : 1;
      var startX = (0 - phaseShift) / frequency;
      
      for (var i = -5; i <= 5; i++) {
        var x = startX + i * period;
        if (x >= ${boundingBox[0]} && x <= ${boundingBox[2]}) {
          board.create('line', [
            [x, -0.1], [x, 0.1]
          ], {
            strokeColor: func.color || '#666666',
            strokeWidth: 1,
            straightFirst: false,
            straightLast: false
          });
          board.create('text', [x, -0.3, i === 0 ? '0' : (i > 0 ? '+' + i + 'T' : i + 'T')], {
            fontSize: 10,
            color: func.color || '#666666',
            anchorX: 'middle'
          });
        }
      }
    });
    `;
  }

  if (analysisOptions.showAmplitudeLines) {
    code += `
    // Add amplitude reference lines
    ${JSON.stringify(functions)}.forEach(function(func) {
      var amplitude = func.transformation ? func.transformation.amplitude || 1 : 1;
      var verticalShift = func.transformation ? func.transformation.verticalShift || 0 : 0;
      
      if (amplitude !== 0) {
        var maxY = amplitude + verticalShift;
        var minY = -amplitude + verticalShift;
        
        board.create('line', [
          [${boundingBox[0]}, maxY], [${boundingBox[2]}, maxY]
        ], {
          strokeColor: func.color || '#999999',
          strokeWidth: 1,
          dash: 1,
          opacity: 0.7,
          straightFirst: false,
          straightLast: false
        });
        
        board.create('line', [
          [${boundingBox[0]}, minY], [${boundingBox[2]}, minY]
        ], {
          strokeColor: func.color || '#999999',
          strokeWidth: 1,
          dash: 1,
          opacity: 0.7,
          straightFirst: false,
          straightLast: false
        });
      }
    });
    `;
  }

  if (analysisOptions.showUnitCircle) {
    code += `
    // Add unit circle reference
    var circle = board.create('circle', [[0, 0], 1], {
      strokeColor: '#cccccc',
      strokeWidth: 1,
      dash: 2,
      fillColor: 'transparent'
    });
    `;
  }

  // Add additional points
  if (points && points.length > 0) {
    points.forEach((point: any, index: number) => {
      code += `
    board.create('point', [${point.x}, ${point.y}], {
      size: ${point.size || 3},
      fillColor: '${point.color || '#ff0000'}',
      strokeColor: '${point.color || '#ff0000'}',
      name: '${point.name || `P${index + 1}`}',
      showInfobox: true
    });
    `;
    });
  }

  // Add unit markers for radians/degrees
  if (xAxisUnit === "radians") {
    code += `
    // Add radian markers
    var radianMarkers = [-2*Math.PI, -Math.PI, -Math.PI/2, Math.PI/2, Math.PI, 2*Math.PI];
    var radianLabels = ['-2π', '-π', '-π/2', 'π/2', 'π', '2π'];
    
    radianMarkers.forEach(function(x, i) {
      if (x >= ${boundingBox[0]} && x <= ${boundingBox[2]}) {
        board.create('point', [x, 0], {
          size: 1,
          fillColor: '#666666',
          strokeColor: '#666666',
          name: '',
          fixed: true
        });
        board.create('text', [x, -0.3, radianLabels[i]], {
          fontSize: 12,
          color: '#666666',
          anchorX: 'middle'
        });
      }
    });
    `;
  }

  // Do not return from within injected code to avoid illegal return in some embedding contexts

  return code;
}
